<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Reconstruct the world space positions of pixels from the depth texture | FSM Unity Framework </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Reconstruct the world space positions of pixels from the depth texture | FSM Unity Framework ">
      
      
      <link rel="icon" href="../../../../images/favicon.ico">
      <link rel="stylesheet" href="../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../toc.html">
      
      <meta name="docfx:rel" content="../../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/acarbonellb33/Unity_FSM_ToolKit/blob/main/Library/PackageCache/com.unity.render-pipelines.universal@14.0.9/Documentation~/writing-shaders-urp-reconstruct-world-position.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../index.html">
            <img id="logo" class="svg" src="../../../../images/logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="reconstruct-the-world-space-positions-of-pixels-from-the-depth-texture">Reconstruct the world space positions of pixels from the depth texture</h1>

<p>The Unity shader in this example reconstructs the world space positions for pixels using a depth texture and screen space UV coordinates. The shader draws a checkerboard pattern on a mesh to visualize the positions.</p>
<p>The following illustration shows the end result:</p>
<p><img src="Images/shader-examples/urp-shader-tutorial-reconstruct-world-positions-from-depth.png" alt="Checkerboard pattern visualizing the reconstructed world space positions."></p>
<p>This page contains the following sections:</p>
<ul>
<li><p><a href="#create-the-sample-scene">Create the sample scene</a></p>
</li>
<li><p><a href="#edit-the-shaderlab-code">Edit the ShaderLab code</a></p>
</li>
<li><p><a href="#the-complete-shaderlab-code">The complete ShaderLab code</a></p>
</li>
</ul>
<h2 id="create-the-sample-scene">Create the sample scene</h2>
<p>Create the sample scene to follow the steps in this section:</p>
<ol>
<li><p>Install URP into an existing Unity project, or create a new project using the <a href="creating-a-new-project-with-urp.html"><strong>Universal Project Template</strong></a>.</p>
</li>
<li><p>In the sample Scene, create a plane GameObject and place it so that it occludes some of the GameObjects.</p>
<p><img src="Images/shader-examples/urp-shader-tutorial-create-place-gameobj.png" alt="Create a plane"></p>
</li>
<li><p>Create a new Material and assign it to the plane.</p>
</li>
<li><p>Create a new shader and assign it to the material. Copy and paste the Unity shader source code from the page <a href="writing-shaders-urp-basic-unlit-structure.html">URP unlit basic shader</a>.</p>
</li>
<li><p>Select the URP Asset. If you created the project using the Universal Render Pipeline template, the URP Asset path is <code>Assets/Settings/UniversalRP-HighQuality</code>.</p>
</li>
<li><p>In the URP Asset, in the General section, enable <code>Depth Texture</code>.</p>
<p><img src="Images/shader-examples/urp-asset-depth-texture.png" alt="In URP Asset, enable Depth Texture"></p>
</li>
<li><p>Open the shader you created on step 4.</p>
</li>
</ol>
<h2 id="edit-the-shaderlab-code">Edit the ShaderLab code</h2>
<p>This section assumes that you copied the source code from the page <a href="writing-shaders-urp-basic-unlit-structure.html">URP unlit basic shader</a>.</p>
<p>Make the following changes to the ShaderLab code:</p>
<ol>
<li><p>In the <code>HLSLPROGRAM</code> block, add the include declaration for the depth texture shader header. For example, place it under the existing include declaration for <code>Core.hlsl</code>.</p>
<pre><code class="lang-c++">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;

// The DeclareDepthTexture.hlsl file contains utilities for sampling the Camera
// depth texture.
#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl&quot;
</code></pre>
<p>The <code>DeclareDepthTexture.hlsl</code> file contains functions for sampling the Camera depth texture. This example uses the <code>SampleSceneDepth</code> function for sampling the Z coordinate for pixels.</p>
</li>
<li><p>In the fragment shader definition, add <code>Varyings IN</code> as input.</p>
<pre><code class="lang-c++">half4 frag(Varyings IN) : SV_Target
</code></pre>
<p>In this example, the fragment shader uses the <code>positionHCS</code> property from the <code>Varyings</code> struct to get locations of pixels.</p>
</li>
<li><p>In the fragment shader, to calculate the UV coordinates for sampling the depth buffer, divide the pixel location by the render target resolution <code>_ScaledScreenParams</code>. The property <code>_ScaledScreenParams.xy</code> takes into account any scaling of the render target, such as Dynamic Resolution.</p>
<pre><code class="lang-c++">float2 UV = IN.positionHCS.xy / _ScaledScreenParams.xy;
</code></pre>
</li>
<li><p>In the fragment shader, use the <code>SampleSceneDepth</code> functions to sample the depth buffer.</p>
<pre><code class="lang-c++">#if UNITY_REVERSED_Z
    real depth = SampleSceneDepth(UV);
#else
    // Adjust z to match NDC for OpenGL
    real depth = lerp(UNITY_NEAR_CLIP_VALUE, 1, SampleSceneDepth(UV));
#endif
</code></pre>
<p>The <code>SampleSceneDepth</code> function comes from the <code>DeclareDepthTexture.hlsl</code> file. It returns the Z value in the range <code>[0, 1]</code>.</p>
<p>For the reconstruction function (<code>ComputeWorldSpacePosition</code>) to work, the depth value must be in the normalized device coordinate (NDC) space. In D3D, Z is in range <code>[0,1]</code>, in OpenGL, Z is in range <code>[-1, 1]</code>.</p>
<p>This example uses the <code>UNITY_REVERSED_Z</code> constant to determine the platform and adjust the Z value range. See step 6 in this example for more explanations.</p>
<p>The <code>UNITY_NEAR_CLIP_VALUE</code> variable is a platform independent near clipping plane value for the clip space.</p>
<p>For more information, see <a href="https://docs.unity3d.com/Manual/SL-PlatformDifferences.html">Platform-specific rendering differences</a>.</p>
</li>
<li><p>Reconstruct world space positions from the UV and Z coordinates of pixels.</p>
<pre><code class="lang-c++">float3 worldPos = ComputeWorldSpacePosition(UV, depth, UNITY_MATRIX_I_VP);
</code></pre>
<p><code>ComputeWorldSpacePosition</code> is a utility function that calculates the world space position from the UV and the depth (Z) values. This function is defined in the <code>Common.hlsl</code> file of the SRP Core package.</p>
<p><code>UNITY_MATRIX_I_VP</code> is an inverse view projection matrix which transforms points from the clip space to the world space.</p>
</li>
<li><p>To visualize the world space positions of pixels, create the checkboard effect.</p>
<pre><code class="lang-c++">uint scale = 10;
uint3 worldIntPos = uint3(abs(worldPos.xyz * scale));
bool white = (worldIntPos.x &amp; 1) ^ (worldIntPos.y &amp; 1) ^ (worldIntPos.z &amp; 1);
half4 color = white ? half4(1,1,1,1) : half4(0,0,0,1);
</code></pre>
<p>The <code>scale</code> is the inverse scale of the checkboard pattern size.</p>
<p>The <code>abs</code> function mirrors the pattern to the negative coordinate side.</p>
<p>The <code>uint3</code> declaration for the <code>worldIntPos</code> variable snaps the coordinate positions to integers.</p>
<p>The <code>AND</code> operator in the expresion <code>&lt;integer value&gt; &amp; 1</code> checks if the value is even (0) or odd (1). The expression lets the code divide the surface into squares.</p>
<p>The <code>XOR</code> operator in the expresion <code>&lt;integer value&gt; ^ &lt;integer value&gt;</code> flips the square color.</p>
<p>The depth buffer might not have valid values for areas where no geometry is rendered. The following code draws black color in such areas.</p>
<pre><code class="lang-c++">#if UNITY_REVERSED_Z
    if(depth &lt; 0.0001)
        return half4(0,0,0,1);
#else
    if(depth &gt; 0.9999)
        return half4(0,0,0,1);
#endif
</code></pre>
<p>Different platforms use different Z values for far clipping planes (0 == far, or 1 == far). The <code>UNITY_REVERSED_Z</code> constant lets the code handle all platforms correctly.</p>
<p>Save the shader code, the example is ready.</p>
</li>
</ol>
<p>The following illustration shows the end result:</p>
<p><img src="Images/shader-examples/urp-shader-tutorial-reconstruct-world-positions-from-depth.png" alt="3D Checkerboard"></p>
<h2 id="the-complete-shaderlab-code">The complete ShaderLab code</h2>
<p>Below is the complete ShaderLab code for this example.</p>
<pre><code class="lang-c++">// This Unity shader reconstructs the world space positions for pixels using a depth
// texture and screen space UV coordinates. The shader draws a checkerboard pattern
// on a mesh to visualize the positions.
Shader &quot;Example/URPReconstructWorldPos&quot;
{
    Properties
    { }

    // The SubShader block containing the Shader code.
    SubShader
    {
        // SubShader Tags define when and under which conditions a SubShader block or
        // a pass is executed.
        Tags { &quot;RenderType&quot; = &quot;Opaque&quot; &quot;RenderPipeline&quot; = &quot;UniversalPipeline&quot; }

        Pass
        {
            HLSLPROGRAM
            // This line defines the name of the vertex shader.
            #pragma vertex vert
            // This line defines the name of the fragment shader.
            #pragma fragment frag

            // The Core.hlsl file contains definitions of frequently used HLSL
            // macros and functions, and also contains #include references to other
            // HLSL files (for example, Common.hlsl, SpaceTransforms.hlsl, etc.).
            #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;

            // The DeclareDepthTexture.hlsl file contains utilities for sampling the
            // Camera depth texture.
            #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl&quot;

            // This example uses the Attributes structure as an input structure in
            // the vertex shader.
            struct Attributes
            {
                // The positionOS variable contains the vertex positions in object
                // space.
                float4 positionOS   : POSITION;
            };

            struct Varyings
            {
                // The positions in this struct must have the SV_POSITION semantic.
                float4 positionHCS  : SV_POSITION;
            };

            // The vertex shader definition with properties defined in the Varyings
            // structure. The type of the vert function must match the type (struct)
            // that it returns.
            Varyings vert(Attributes IN)
            {
                // Declaring the output object (OUT) with the Varyings struct.
                Varyings OUT;
                // The TransformObjectToHClip function transforms vertex positions
                // from object space to homogenous clip space.
                OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);
                // Returning the output.
                return OUT;
            }

            // The fragment shader definition.
            // The Varyings input structure contains interpolated values from the
            // vertex shader. The fragment shader uses the `positionHCS` property
            // from the `Varyings` struct to get locations of pixels.
            half4 frag(Varyings IN) : SV_Target
            {
                // To calculate the UV coordinates for sampling the depth buffer,
                // divide the pixel location by the render target resolution
                // _ScaledScreenParams.
                float2 UV = IN.positionHCS.xy / _ScaledScreenParams.xy;

                // Sample the depth from the Camera depth texture.
                #if UNITY_REVERSED_Z
                    real depth = SampleSceneDepth(UV);
                #else
                    // Adjust Z to match NDC for OpenGL ([-1, 1])
                    real depth = lerp(UNITY_NEAR_CLIP_VALUE, 1, SampleSceneDepth(UV));
                #endif

                // Reconstruct the world space positions.
                float3 worldPos = ComputeWorldSpacePosition(UV, depth, UNITY_MATRIX_I_VP);

                // The following part creates the checkerboard effect.
                // Scale is the inverse size of the squares.
                uint scale = 10;
                // Scale, mirror and snap the coordinates.
                uint3 worldIntPos = uint3(abs(worldPos.xyz * scale));
                // Divide the surface into squares. Calculate the color ID value.
                bool white = ((worldIntPos.x) &amp; 1) ^ (worldIntPos.y &amp; 1) ^ (worldIntPos.z &amp; 1);
                // Color the square based on the ID value (black or white).
                half4 color = white ? half4(1,1,1,1) : half4(0,0,0,1);

                // Set the color to black in the proximity to the far clipping
                // plane.
                #if UNITY_REVERSED_Z
                    // Case for platforms with REVERSED_Z, such as D3D.
                    if(depth &lt; 0.0001)
                        return half4(0,0,0,1);
                #else
                    // Case for platforms without REVERSED_Z, such as OpenGL.
                    if(depth &gt; 0.9999)
                        return half4(0,0,0,1);
                #endif

                return color;
            }
            ENDHLSL
        }
    }
}
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/acarbonellb33/Unity_FSM_ToolKit/blob/main/Library/PackageCache/com.unity.render-pipelines.universal@14.0.9/Documentation~/writing-shaders-urp-reconstruct-world-position.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
