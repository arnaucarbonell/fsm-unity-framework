<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>The RTHandle system | FSM Unity Framework </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="The RTHandle system | FSM Unity Framework ">
      
      
      <link rel="icon" href="../../../../images/favicon.ico">
      <link rel="stylesheet" href="../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../toc.html">
      
      <meta name="docfx:rel" content="../../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/acarbonellb33/Unity_FSM_ToolKit/blob/main/Library/PackageCache/com.unity.render-pipelines.core@14.0.9/Documentation~/rthandle-system.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../index.html">
            <img id="logo" class="svg" src="../../../../images/logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="the-rthandle-system">The RTHandle system</h1>

<p>Render target management is an important part of any render pipeline. In a complicated render pipeline where there are many interdependent render passes that use many different render textures, it is important to have a maintainable and extendable system that allows for easy memory management.</p>
<p>One of the biggest issues occurs when a render pipeline uses many different Cameras, each with their own resolution. For example, off-screen Cameras or real-time reflection probes. In this scenario, if the system allocated render textures independently for each Camera, the total amount of memory would increase to unmanageable levels. This is particularly bad for complex render pipelines that use many intermediate render textures. Unity can use <a href="https://docs.unity3d.com/ScriptReference/RenderTexture.GetTemporary.html">temporary render textures</a>, but unfortunately, they do not suit this kind of use case because temporary render textures can only reuse memory if a new render texture uses the exact same properties and resolution. This means that when rendering with two different resolutions, the total amount of memory Unity uses is the sum of all resolutions.</p>
<p>To solve these issues with render texture memory allocation, Unity's Scriptable Render Pipeline includes the RTHandle system. This system is an abstraction layer on top of Unity's <a href="https://docs.unity3d.com/ScriptReference/RenderTexture.html">RenderTexture</a> API that handles render texture management automatically.</p>
<p>This section contains the following pages:</p>
<ul>
<li><a href="rthandle-system-fundamentals.html">RTHandle system fundamentals</a></li>
<li><a href="rthandle-system-using.html">Using the RTHandle system</a></li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/acarbonellb33/Unity_FSM_ToolKit/blob/main/Library/PackageCache/com.unity.render-pipelines.core@14.0.9/Documentation~/rthandle-system.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
