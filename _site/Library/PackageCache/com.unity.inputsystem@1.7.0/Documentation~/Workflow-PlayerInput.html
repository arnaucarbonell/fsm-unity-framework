<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Workflow Overview - Using an Actions Asset and PlayerInput Component | FSM Unity Framework </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Workflow Overview - Using an Actions Asset and PlayerInput Component | FSM Unity Framework ">
      
      
      <link rel="icon" href="../../../../images/favicon.ico">
      <link rel="stylesheet" href="../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../toc.html">
      
      <meta name="docfx:rel" content="../../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/acarbonellb33/Unity_FSM_ToolKit/blob/main/Library/PackageCache/com.unity.inputsystem@1.7.0/Documentation~/Workflow-PlayerInput.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../index.html">
            <img id="logo" class="svg" src="../../../../images/logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="input-system-workflow-player-input">
<h1 id="workflow-overview---using-an-actions-asset-and-playerinput-component">Workflow Overview - Using an Actions Asset and PlayerInput Component</h1>

<p><img src="./Images/Workflow-PlayerInput.svg" alt="image alt text"></p>
<p>The highest level of abstraction provided by the Input System is when you use the <a href="ActionAssets.html">Actions Asset</a> and the <strong>Player Input component</strong> together.</p>
<p>The Player Input component takes a reference to an Actions Asset, and provides a way to make connections between the Actions defined in that asset, and C# methods in your own MonoBehaviour scripts, so that your desired C# methods are called when the user performs an input action.</p>
<p>It allows you to set up these connections using a UI in the inspector, instead of requiring you to write code to make those connections (as shown in the <a href="Workflow-ActionsAsset.html">previous workflow example</a>), as well as letting you choose how those methods are called.</p>
<p>You would typically add the PlayerInput component to the same GameObject as your own MonoBehaviour script which contains the methods that should handle the response to the actions.</p>
<p><img src="./Images/PlayerInputWithGameplayEvents.png" alt="image alt text"></p>
<p>In the above example image, you can see the PlayerInput component set up to map the &quot;move&quot;, &quot;jump&quot; actions to <code>OnMove</code> and <code>OnJump</code> methods in a script, via Unity Events.</p>
<p>This is an example of the script which would provide an implementation of these methods</p>
<pre><code>using UnityEngine;
using UnityEngine.InputSystem;

// This script is designed to have the OnMove and
// OnJump methods called by a PlayerInput component

public class ExampleScript : MonoBehaviour
{
    Vector2 moveAmount;

    public void OnMove(InputAction.CallbackContext context)
    {
        // read the value for the &quot;move&quot; action each event call
        moveAmount = context.ReadValue&lt;Vector2&gt;();
    }

    public void OnJump(InputAction.CallbackContext context)
    {
        // your jump code goes here.
    }

    public void Update()
    {
        // to use the Vector2 value from the &quot;move&quot; action each
        // frame, use the &quot;moveAmount&quot; variable here.
    }

}
</code></pre>
<p>This workflow has pros and cons when compared to the previous workflow which uses an <a href="Workflow-ActionsAsset.html">Action Asset without a PlayerInput component</a>.</p>
<p>You can see compared with the previous workflow code example that this method requires less code, because you do not have to reference the Actions Asset or set up the event handler methods in your own script. However it does require more set-up in the Editor, and could make debugging more difficult because the connections between your actions and code are not hard-coded.</p>
<p>As with the other workflows described in this section, there is a trade-off between flexibility, simplicity, and speed of implementation.</p>
<p>Using the Player Input component provides the flexibility of being able to connect any action to any public method on a GameObject’s component without writing code, and allows you to make modifications to these connections without modifying code.</p>
<p>However, although requiring less code, you may find that coding the connections in your own script is simpler and faster than setting up and keeping track of these connections in a PlayerInput component on a GameObject.</p>
<p>To get started using this workflow, <a href="PlayerInput.html">see the documentation for the Player Input component</a>.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/acarbonellb33/Unity_FSM_ToolKit/blob/main/Library/PackageCache/com.unity.inputsystem@1.7.0/Documentation~/Workflow-PlayerInput.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
